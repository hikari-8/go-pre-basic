package main

import "fmt"

func main(){
	// Go言語において、ポインタは変数のアドレス空間を指すものです。
	// アドレス空間はコンピュータのメモリ上における特定の位置を示すもので、
	// ポインタを使うことで、変数が存在するその位置を直接参照したり操作したりすることができます。
	var i int = 100
	Double(i) //コピーされた値が渡されている
	fmt.Println(i)

	// 参照渡し
	var ip *int = &i
	fmt.Println(ip)
	fmt.Println(*ip) // dereference メモリ上のアドレスを経由して、アドレス本体を参照する仕組みのこと　

	// 値の更新もできる
	*ip = 200
	fmt.Println(i)
	i = 150
	fmt.Println(*ip) 

	Doublev2(&i)
	fmt.Println(i)

	Doublev2(ip)
	fmt.Println(*ip)
}

func Double(num int) {
	num = num*2 
}

func Doublev2(i *int) {
	*i = *i * 2
}

// Tips
// Go言語において、
// 値型（基本型のようなint, float64, structsなど）
// と参照型（slices, maps, channelsなど）は、メモリ上での取り扱いが異なります。
// これに関連して、ポインタの使用の必要性が変わってきます。

// ### 値型:

// 値型の変数はメモリ上に実際のデータを持ちます。
// このデータを関数に渡すとき、そのデータのコピーが渡されます。
// このコピーの動作を避け、変数の実際のメモリ位置（アドレス）にアクセスする必要がある場合、ポインタを使用します。


// ### 参照型:

// 参照型の変数は、データそのものではなく、データへの参照（メモリアドレス）を保持しています。
// そのため、関数に参照型を渡すと、データのコピーではなく参照が渡されるため、元のデータに直接変更を加えることができます。
// この特性のため、参照型でポインタを使用することは稀であり、通常は不要です。
// これらの動作の背後にある理由は、パフォーマンスとメモリ効率です。
// 値型のデータが大きい場合、そのデータを常にコピーするとパフォーマンスの低下やメモリの無駄な使用が生じる可能性があります。
// ポインタを使用することで、このようなオーバーヘッドを避けることができます。一方、参照型は元々参照として動作するので、この問題は発生しません。